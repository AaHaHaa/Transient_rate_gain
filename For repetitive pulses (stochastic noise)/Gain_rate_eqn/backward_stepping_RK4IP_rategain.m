function [A1t_backward,...
          Power_pump_backward,...
          N,dN] = backward_stepping_RK4IP_rategain(A0t_forward,A0t_backward,...
                                                   Power_pump_forward,Power_pump_backward,...
                                                   N,dN,...
                                                   Nt,dt,num_windows,...
                                                   sim,gain_rate_eqn,...
                                                   At_noise)
%BACKWARD_STEPPING_RK4IP_RATEGAIN Take one step with RK4IP with a gain 
%model solved from rate equations.
%
% Input:
%    A0t_forward - initial forward-propagating field in the time domain
%                  a (1,1,1,num_windows) cell array, each containing a (Nt,1) array; sqrt(W)
%    A0t_backward - initial backward-propagating field in the time domain
%                  a (1,1,1,num_windows) cell array, each containing a (Nt,1) array; sqrt(W)
%
%    Power_pump_forward - the power of the co-propagating pump
%                         a (1,1,1,num_windows) cell array, each containing a (Nt,1) array; in W
%    Power_pump_backward - the power of the counter-propagating pump
%                          a (1,1,1,num_windows) cell array, each containing a (Nt,1) array; in W
%
%    N - populations
%        a (1,1,1,num_windows) cell array, each containing a (Nt,num_levels-1) array; in m^(-3)
%    dN - (1,num_levels-1); the population variations over one dz
%
%    Nt - the number of sampling points
%    dt - time grid point spacing; ps;  a (1,num_windows) array
%    num_windows - the number of windows
%
%    sim - container for simulation parameters
%    gain_rate_eqn - container for rate-eqn parameters
%
% Output:
%    A1t_backward - the backward-propagating field in the time domain after one step size
%                  a (1,1,1,num_windows) cell array, each containing a (Nt,1) array; sqrt(W)
%    Power_pump_backward - the power of the counter-propagating pump
%                         a (1,1,1,num_windows) cell array, each containing a (Nt,1) array; in W
%    N - populations
%        a (1,1,1,num_windows) cell array, each containing a (Nt,num_levels-1) array; in m^(-3)
%    dN - (1,num_levels-1); the population variations over one dz
                            
A1t_backward = cell(1,1,1,num_windows);

% =========================================================================
% Find the population N(t) under the periodic boundary condition
% =========================================================================
[N,dN,...
 extended_A0w_backward,extended_Power_pump_backward] = find_periodic_transient_N('backward',...
                                                                                 sim,gain_rate_eqn,...
                                                                                 Nt,dt,num_windows,...
                                                                                 N,dN,...
                                                                                 A0t_forward,A0t_backward,...
                                                                                 Power_pump_forward,Power_pump_backward);

% =========================================================================
% Finished finding the population N and start to compute the field (signal 
% fields and ASE) and the pump power
% =========================================================================

extended_N = cellfun(@(x) gain_rate_eqn.acyclic_zero_padding(x), N,'UniformOutput',false);

func = solve_gain_rate_eqn_helpers();
dPdz_pump_backward = func.solve_pump(gain_rate_eqn,...
                                     extended_N,...
                                     extended_Power_pump_backward);

% -------------------------------------------------------------------------
% Without coherent pulses
% -------------------------------------------------------------------------

for window_i = 1:2:num_windows
    % Pump power is found with a simple Newton's method
    Power_pump_backward{window_i} = Power_pump_backward{window_i} + dPdz_pump_backward{window_i}(1:Nt)*sim.dz;
    % Pump power cannot be negative
    Power_pump_backward{window_i}(Power_pump_backward{window_i}<0) = 0;

    dAt_SE1 = func.solve_Power('sponASE',...
                               gain_rate_eqn,...
                               sim.dz,...
                               gain_rate_eqn.extended_cross_sections{1},...
                               extended_N{window_i},...
                               [],abs(ifft(At_noise{window_i},[],1)).^2,[]);
    % Field is found with RK4
    A1t_backward{window_i} = RK4_ASE(extended_A0w_backward{window_i},...
                                     gain_rate_eqn,...
                                     gain_rate_eqn.extended_cross_sections{1},...
                                     sim.dz,...
                                     extended_N{window_i},...
                                     dAt_SE1);
end

% -------------------------------------------------------------------------
% With coherent pulses
% -------------------------------------------------------------------------

for window_i = 2:2:num_windows
    % Pump power is found with a simple Newton's method
    Power_pump_backward{window_i} = Power_pump_backward{window_i} + dPdz_pump_backward{window_i}(1:Nt)*sim.dz;
    % Pump power cannot be negative
    Power_pump_backward{window_i}(Power_pump_backward{window_i}<0) = 0;

    dAt_SE2 = func.solve_Power('sponASE',...
                               gain_rate_eqn,...
                               sim.dz,...
                               gain_rate_eqn.extended_cross_sections{2},...
                               extended_N{window_i},...
                               [],abs(ifft(At_noise{window_i},[],1)).^2,[]);
    % Field is found with RK4
    A1t_backward{window_i} = RK4_ASE(extended_A0w_backward{window_i},...
                                     gain_rate_eqn,...
                                     gain_rate_eqn.extended_cross_sections{2},...
                                     sim.dz,...
                                     extended_N{window_i},...
                                     dAt_SE2);
end

% Downsample it back to the original time window
for window_i = 1:num_windows
    A1t_backward{window_i} = A1t_backward{window_i}(1:Nt);
end

end

%% RK4 for ASE
function A1t = RK4_ASE(A0w,...
                       gain_rate_eqn,...
                       cross_sections,...
                       dz,...
                       N,...
                       dAt_SE)

a1 = N_op_ASE(A0w,...
              gain_rate_eqn,...
              cross_sections,...
              N);
a2 = N_op_ASE(A0w+a1*(dz/2),...
              gain_rate_eqn,...
              cross_sections,...
              N);
a3 = N_op_ASE(A0w+a2*(dz/2),...
              gain_rate_eqn,...
              cross_sections,...
              N);
a4 = N_op_ASE(A0w+a3*(dz),...
              gain_rate_eqn,...
              cross_sections,...
              N);

A1 = A0w + (a1+2*a2+2*a3+a4)*(dz/6);

A1t = fft(A1,[],1) + dAt_SE; % add spontaneous emission

end
% and the nonlinear operator in RK4_ASE
function dAwdz = N_op_ASE(Aw,...
                          gain_rate_eqn,...
                          cross_sections,...
                          N)
%N_op_ASE Calculate dAwdz

% Gain term
func = solve_gain_rate_eqn_helpers();
gAt = func.solve_Power('signal',...
                       gain_rate_eqn,...
                       [],...
                       cross_sections,...
                       N,...
                       [],[],Aw);

dAwdz = ifft(gAt,[],1);

end